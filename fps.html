<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu FPS Simple</title>
   <link rel="stylesheet" href="./style.css">
</head>
<body>
    <div id="startButtonContainer">
        <h1>FPS Simple</h1>
        <p>Détruisez les cubes !</p>
        <button id="startButton">Démarrer le Jeu</button>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="crosshair"></div>
    <div id="instructions">
        ZQSD/WASD: Déplacement<br>
        Souris: Regarder<br>
        Clic Gauche: Tirer<br>
        Échap: Libérer la souris
    </div>
    <div id="scoreDisplay">Score: 0</div>
    <div id="messageBox"></div>
    <audio id="shootSound" src="https://assets.codepen.io/21542/howler-gun-shot.mp3" preload="auto"></audio>
    <audio id="hitSound" src="https://assets.codepen.io/21542/howler-hit.mp3" preload="auto"></audio>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // --- Global Variables ---
        let scene, camera, renderer;
        let player, playerVelocity, playerOnFloor;
        const playerHeight = 1.8;
        const playerSpeed = 8.0;
        const playerJumpVelocity = 8.0;
        const gravity = 20.0; // Adjusted gravity for a more responsive feel
        let difficultyLevel = 1;
        
        let controlsEnabled = false;
        let targets = [];
        let score = 0;

        const moveForward = { value: false };
        const moveBackward = { value: false };
        const moveLeft = { value: false };
        const moveRight = { value: false };

        const gameCanvas = document.getElementById('gameCanvas');
        const crosshair = document.getElementById('crosshair');
        const startButtonContainer = document.getElementById('startButtonContainer');
        const startButton = document.getElementById('startButton');
        const instructionsDiv = document.getElementById('instructions');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const messageBox = document.getElementById('messageBox');

        let prevTime = performance.now(); // For delta time calculation

        // Variables globales
        let shootSound, hitSound;

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Sky blue background
            scene.fog = new THREE.Fog(0x87ceeb, 0, 100); // Fog for depth perception

            // Camera (PerspectiveCamera for 3D)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = playerHeight; // Player's eye level

            // Player object (a simple group to hold the camera)
            player = new THREE.Group();
            player.add(camera);
            player.position.set(0, playerHeight, 5); // Initial player position
            scene.add(player);
            
            playerVelocity = new THREE.Vector3();
            playerOnFloor = false;

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // For sharper rendering on high DPI screens
            renderer.shadowMap.enabled = true; // Enable shadows for more realism

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Soft ambient light
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Sun-like light
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            // Configure shadow properties for optimization
            directionalLight.shadow.mapSize.width = 1024; 
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            scene.add(directionalLight);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
            groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(20, 20);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                map: groundTexture,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            ground.receiveShadow = true;
            scene.add(ground);

            // Skybox
            const skyTexture = new THREE.TextureLoader().load('./sky.jpg');
            scene.background = skyTexture;

            // Targets
            spawnTargets(10);

            // Particles
            createParticleSystem();

            // Sounds
            shootSound = document.getElementById('shootSound');
            hitSound = document.getElementById('hitSound');

            // Event Listeners
            startButton.addEventListener('click', startGame);
            document.addEventListener('pointerlockchange', pointerLockChange, false);
            document.addEventListener('mozpointerlockchange', pointerLockChange, false); // Firefox
            document.addEventListener('webkitpointerlockchange', pointerLockChange, false); // Chrome, Safari, Opera
            document.addEventListener('pointerlockerror', pointerLockError, false);
            document.addEventListener('mozpointerlockerror', pointerLockError, false);
            document.addEventListener('webkitpointerlockerror', pointerLockError, false);

            window.addEventListener('resize', onWindowResize, false);
        }

        // --- Game Logic ---
       // Modifier startGame()
        function startGame() {
            startButtonContainer.style.display = 'none';
            crosshair.style.display = 'block';
            instructionsDiv.style.display = 'block';
            scoreDisplay.style.display = 'block';
            
            // Réinitialiser le jeu
            score = 0;
            gameTime = 0;
            gameActive = true;
            targets.forEach(target => scene.remove(target));
            targets = [];
            spawnTargets(10);
            
            // Position initiale du joueur
            player.position.set(0, playerHeight, 5);
            player.rotation.set(0, 0, 0);
            camera.rotation.set(0, 0, 0);
            
            gameCanvas.requestPointerLock();
        }

        function pointerLockChange() {
            if (document.pointerLockElement === gameCanvas ||
                document.mozPointerLockElement === gameCanvas ||
                document.webkitPointerLockElement === gameCanvas) {
                controlsEnabled = true;
                // Hook mouse move and click events
                document.addEventListener('mousemove', onMouseMove, false);
                document.addEventListener('mousedown', onMouseDown, false);
                document.addEventListener('keydown', onKeyDown, false);
                document.addEventListener('keyup', onKeyUp, false);
                showMessage("Contrôles activés. Appuyez sur Échap pour libérer.", 3000);
            } else {
                controlsEnabled = false;
                // Unhook events
                document.removeEventListener('mousemove', onMouseMove, false);
                document.removeEventListener('mousedown', onMouseDown, false);
                document.removeEventListener('keydown', onKeyDown, false);
                document.removeEventListener('keyup', onKeyUp, false);
                
                // Show start screen again if game was active
                startButtonContainer.style.display = 'flex';
                crosshair.style.display = 'none';
                instructionsDiv.style.display = 'none';
                // scoreDisplay.style.display = 'none'; // Keep score visible or hide
                showMessage("Contrôles désactivés.", 2000);
            }
        }

        function pointerLockError() {
            console.error('PointerLock Error');
            showMessage("Erreur de verrouillage du pointeur.", 3000);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            if (!controlsEnabled) return;
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                case 'KeyZ': // For AZERTY keyboards
                    moveForward.value = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                case 'KeyQ': // For AZERTY keyboards
                    moveLeft.value = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward.value = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight.value = true;
                    break;
                case 'Space':
                    if (playerOnFloor) {
                         playerVelocity.y = playerJumpVelocity;
                         playerOnFloor = false; // Player is now in the air
                    }
                    break;
                case 'Escape':
                    document.exitPointerLock = document.exitPointerLock ||
                                                document.mozExitPointerLock ||
                                                document.webkitExitPointerLock;
                    document.exitPointerLock();
                    break;
            }
        }

        function onKeyUp(event) {
            if (!controlsEnabled) return;
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                case 'KeyZ':
                    moveForward.value = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                case 'KeyQ':
                    moveLeft.value = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward.value = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight.value = false;
                    break;
            }
        }
        
        const euler = new THREE.Euler(0, 0, 0, 'YXZ'); // To control camera rotation
        const PI_2 = Math.PI / 2;

        function onMouseMove(event) {
            if (!controlsEnabled) return;

            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

            euler.setFromQuaternion(camera.quaternion);
            euler.y -= movementX * 0.002;
            euler.x -= movementY * 0.002;
            euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x)); // Clamp vertical rotation

            camera.quaternion.setFromEuler(euler);
        }

        function onMouseDown(event) {
            if (!controlsEnabled || event.button !== 0) return;

            shootSound.currentTime = 0;
            shootSound.play();

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);

            const intersects = raycaster.intersectObjects(targets);
            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                if (targets.includes(intersectedObject)) {

                    hitSound.currentTime = 0;
                    hitSound.play();

                    createExplosion(intersectedObject.position);

                    scene.remove(intersectedObject);
                    intersectedObject.geometry.dispose();
                    intersectedObject.material.dispose();
                    targets = targets.filter(target => target !== intersectedObject);
                    
                    // Points en fonction de la couleur
                    if (intersectedObject.material.color.getHex() === 0xff0000) {
                        score += 10; // Rouge = 10 points
                        showMessage("Cible rouge ! +10 points", 1000);
                    } else if (intersectedObject.material.color.getHex() === 0x00ff00) {
                        score += 20; // Vert = 20 points
                        showMessage("Cible verte ! +20 points", 1000);
                    } else {
                        score += 5; // Bleu = 5 points
                        showMessage("Cible bleue ! +5 points", 1000);
                    }
                    
                    updateScoreDisplay();

                    if (targets.length === 0) {
                        if (score > highScore) {
                            highScore = score;
                            showMessage("Nouveau record ! Nouvelles cibles dans 3s.", 3000);
                        } else {
                            showMessage("Toutes les cibles détruites ! Nouvelles cibles dans 3s.", 3000);
                        }
                        difficultyLevel += 0.5;
                        
                        setTimeout(() => {
                            spawnTargets(10 + Math.floor(score/50))
                            showMessage(`Niveau ${Math.floor(difficultyLevel)}!`, 2000);
                        }, 3000);
                    }
                }
            }
        }

        // Ajouter ces variables globales
        let gameTime = 0;
        let highScore = 0;
        let gameActive = false;

        // Modifier la fonction spawnTargets()
        function spawnTargets(count) {
            const targetGeometry = new THREE.BoxGeometry(1, 1, 1);
            const materials = [
                new THREE.MeshStandardMaterial({ color: 0xff0000 }), // Rouge
                new THREE.MeshStandardMaterial({ color: 0x00ff00 }), // Vert
                new THREE.MeshStandardMaterial({ color: 0x0000ff })  // Bleu
            ];
            
            for (let i = 0; i < count; i++) {
                const materialIndex = Math.floor(Math.random() * materials.length);
                const target = new THREE.Mesh(targetGeometry, materials[materialIndex]);
                
                // Position aléatoire mais plus intelligente
                const angle = Math.random() * Math.PI * 2;
                const radius = 10 + Math.random() * 30;
                target.position.set(
                    Math.cos(angle) * radius,
                    Math.random() * 5 + 0.5,
                    Math.sin(angle) * radius
                );

                const size = 1 - (difficultyLevel * 0.05);
                target.scale.set(size, size, size);
                
                // Ajouter une animation de rotation
                target.userData.rotationSpeed = {
                    x: (Math.random() * 0.02 - 0.01) * difficultyLevel,
                    y: (Math.random() * 0.02 - 0.01) * difficultyLevel,
                    z: (Math.random() * 0.02 - 0.01) * difficultyLevel
                };
                
                target.castShadow = true;
                scene.add(target);
                targets.push(target);
            }
        }

        // Créer un système de particules pour les explosions
        let particleSystem;
        function createParticleSystem() {
            const particleCount = 200;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 2;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 2;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
                
                colors[i * 3] = Math.random();
                colors[i * 3 + 1] = Math.random();
                colors[i * 3 + 2] = Math.random();
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
            particleSystem.visible = false;
        }

        function createExplosion(position) {
            particleSystem.position.copy(position);
            particleSystem.visible = true;
            
            // Animation des particules
            const positions = particleSystem.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i] = (Math.random() - 0.5) * 2;
                positions[i + 1] = (Math.random() - 0.5) * 2;
                positions[i + 2] = (Math.random() - 0.5) * 2;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
            
            setTimeout(() => {
                particleSystem.visible = false;
            }, 500);
        }

        function updateScoreDisplay() {
            scoreDisplay.innerHTML = `
                Score: ${score}<br>
                Temps: ${Math.floor(gameTime)}s<br>
                Meilleur score: ${highScore}
            `;
        }
        
        let messageTimeout;
        function showMessage(text, duration = 2000) {
            messageBox.textContent = text;
            messageBox.style.display = 'block';
            clearTimeout(messageTimeout);
            messageTimeout = setTimeout(() => {
                messageBox.style.display = 'none';
            }, duration);
        }
        
        function updatePlayer(deltaTime) {
            if (!controlsEnabled) return;

            const speedDelta = playerSpeed * deltaTime;
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction); // Get camera's current facing direction

            // Horizontal movement
            const right = new THREE.Vector3();
            right.crossVectors(camera.up, direction).normalize(); // Calculate right vector relative to camera

            if (moveForward.value) {
                player.position.addScaledVector(direction, speedDelta);
            }
            if (moveBackward.value) {
                player.position.addScaledVector(direction, -speedDelta);
            }
            if (moveLeft.value) {
                player.position.addScaledVector(right, speedDelta); // Move along the right vector (negated for left)
            }
            if (moveRight.value) {
                player.position.addScaledVector(right, -speedDelta); // Move along the right vector
            }
            
            // Vertical movement (gravity and jump)
            playerVelocity.y -= gravity * deltaTime;
            player.position.y += playerVelocity.y * deltaTime;

            // Collision with floor
            if (player.position.y < playerHeight) {
                player.position.y = playerHeight;
                playerVelocity.y = 0;
                playerOnFloor = true;
            } else {
                playerOnFloor = false;
            }

            // Keep player within bounds (optional, simple example)
            player.position.x = Math.max(-98, Math.min(98, player.position.x));
            player.position.z = Math.max(-98, Math.min(98, player.position.z));
        }


        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const deltaTime = (time - prevTime) / 1000;
            prevTime = time;

            if (gameActive) {
                gameTime += deltaTime;
                updatePlayer(deltaTime);
                
                // Animer les cibles
                targets.forEach(target => {
                    target.rotation.x += target.userData.rotationSpeed.x;
                    target.rotation.y += target.userData.rotationSpeed.y;
                    target.rotation.z += target.userData.rotationSpeed.z;
                });
            }

            renderer.render(scene, camera);
        }

        // --- Start ---
        init();
        animate(); // Start the animation loop
        
        // Ensure canvas is focused for initial interaction if pointer lock fails immediately
        // This is more of a fallback, primary interaction is through startButton
        gameCanvas.focus(); 
    </script>
</body>
</html>
